import { loadVacanciesIfNeeded, getVacanciesData, getLanguagesData, loadLanguagesIfNeeded } from './api.js';



// Текущая локализованная дата и время пользователя округлённая до начала часа (без минут и секунд) (для корректного отображения времени в графиках)
const now = new Date(); now.setMinutes(0, 0, 0);


// === Адаптивная верстка (для мобильной версии) (инициализировать до chartLayout) === //
const isMobile = window.innerWidth <= 720;



// === Общий базовый макет графиков (внешний вид, ось Y, отступы, шрифт, легенда и т.д.) === //
const chartLayout = {
    height    : isMobile ? 300:400, // Высота графика в пикселях (иначе Plotly задаст свою высоту, она может оказаться как большой, так и маленькой)
    margin    : { t: 0, r: 0, l: isMobile ? 70 : 100 },     // Отступы от самой сетки графика сверху и справа (иначе будет пустое место на странице)
    hovermode : 'closest',          // Показывать подсказку при наведении на ближайшую точку

    yaxis: {
        title: {
            text: 'Количество открытых вакансий', // Название оси Y (что именно обозначает ось)
            standoff: isMobile ? 10:20,           // Отступ от оси Y до подписи (иначе текст может прилипать к оси)
        },
        tickformat: ',.0f',                       // Формат чисел на оси: целые числа с разделителями (иначе будут длинные/некрасивые числа)
        // automargin: true                       // Автоматически добавлять отступы, если подписи находятся в границах графика (иначе возможен обрез текста)
                                                  // но если он включен, подпись Y графика начинает заметно визуально смещаться при переключении daily/hourly - оба варианта с минусами, нужен фикс
    }, // Настройки оси Y (количество вакансий)

    font: {
        family: 'Exo 2',            // шрифт для всего текста графика (иначе будет стандартный шрифт Plotly и стиль будет отличаться от общего дизайна)
        size  : isMobile ? 11 : 12, // Размер шрифта, адаптированный под мобильный/десктоп (иначе может быть нечитаемо на мобильных)
        weight: 'bold'              // Жирный шрифт (иначе текст может быть менее контрастным и плохо читаемым)
    },     // Общие настройки шрифта

    legend: {
        orientation: 'h',                   // Горизонтальное расположение (иначе по умолчанию вертикальное)
        x: isMobile ? 0.4 : 0.5,            // Позиционирует легенду на 50% ширины графика (т.е. по центру оси X) (иначе легенда будет слева)
        y: isMobile ? -0.3 : 1.2,           // Позиционирует легенду выше или ниже относительно графика (1.2 => значит на 20% выше графика) (иначе может перекрывать ось X)
        xanchor: 'center',                  // Привязка по центру относительно оси X (иначе легенда может уехать вбок)
        yanchor: 'top',                     // Привязка по верхнему краю относительно оси y (иначе легенда может быть не там, где ожидается)
        font: { size: isMobile ? 9 : 12 },  // Размер шрифта в легенде (иначе может не совпадать со шрифтом графика)
        bgcolor: 'rgba(255,255,255,0)',     // Прозрачный фон (иначе может быть серый фон по умолчанию)
        borderwidth: 0,                     // Убираем рамку у легенды (иначе появляется тонкая рамка вокруг)
        itemclick: 'toggleothers',          // Один клик включает выбранную линию и выключает все остальные (иначе все линии могут включаться/выключаться по отдельности, сложнее анализа)
    }   // Настройки легенды графика
};



// === Часовой график (отталкивается от базового (Y))(отображает в оси X тики => последние 24 часа) === //
const hourlyChartLayout = (() => {


    // Количество дней, которые нужно показать на графике (включая сегодня)
    const ticks = 24;

    // Создаём "end" как начало следующего часа от текущего времени (для визуального отступа) (иначе график будет рисоваться до конца сетки, некрасиво)
    const end   = new Date(now); end.setHours(now.getHours() + 1);

    // Начальная точка: 24 часа назад от конечной точки
    const start = new Date(end); start.setHours(start.getHours() - ticks);

    // Запас слева: на 1 час раньше старта (для визуального отступа) (иначе график будет рисоваться сразу от оси Y)
    const begin = new Date(start); begin.setHours(begin.getHours() - 1);


    // точки на временной шкале X, где будут деления. (иначе Plotly сам выберет метки времени, они могут быть неравномерными)
    const tickVals  = [];
    // подписи к этим делениям на оси X (иначе график может отображать дату/время в неудобном формате)
    const tickTexts = [];


    // Достаём значения каждого часа от start до now
    for (let t = new Date(start), i = 0; t <= now; t.setHours(t.getHours() + 1), i++) {

        // На мобильных показываем только каждый второй час (для читаемости), на десктопе — все (иначе метки будут слишком плотными на мобильном)
        if (!isMobile || i % 2 === 1) {

            // добавляем значение времени для деления оси X
            tickVals.push(new Date(t));

            // Форматируем подпись как HH:00
            tickTexts.push(t.getHours().toString().padStart(2, '0') + ':00');
        }
    }


    // Возвращаем конфигурацию оси X для почасового графика
    return {
        ...chartLayout, // берём базовую разметку графика (иначе не будут применены общие стили)
        xaxis: {
            range     : [begin, end], // явно задаём диапазон оси X (иначе Plotly может его подрезать)
            type      : 'date',       // ось X — это временная шкала (иначе Plotly может не понять формат значений)
            tickvals  : tickVals,     // значения, где должны быть деления на оси X
            ticktext  : tickTexts,    // отображаем свои подписи (иначе Plotly покажет ISO-формат или даты)
            tickangle : -90,          // поворачиваем подписи вертикально для лучшей читаемости (иначе подписи могут накладываться)
        }
    };
})();



// === Дневной график (отталкивается от базового (Y)) (отображает в оси X тики => последние 31 день) === //
const dailyChartLayout = (() => {


    // Количество дней, которые нужно показать на графике (включая сегодня)
    const ticks = 31;

    // Создаём "end" как начало следующего дня от текущего времени (для визуального отступа) (иначе график будет рисоваться до конца сетки, некрасиво)
    const end = new Date(now); end.setDate(now.getDate() + 1);

    // Начальная точка: 31 день назад от конца
    const start = new Date(end); start.setDate(start.getDate() - ticks);

    // Запас слева: на 12 часов раньше старта (для визуального отступа) (иначе график будет рисоваться сразу от оси Y)
    const begin = new Date(start); begin.setHours(begin.getHours() - 12);


    // точки на временной шкале X, где будут деления. (иначе Plotly сам выберет метки времени, они могут быть неравномерными)
    const tickVals = [];
    // подписи к этим делениям на оси X (иначе график может отображать дату/время в неудобном формате)
    const tickTexts = [];

    // Достаём значения каждого дня от start до now
    for (let d = new Date(start), i = 0; d <= now; d.setDate(d.getDate() + 1), i++) {

        // На мобильных показываем только каждый второй день (для читаемости), на десктопе — все (иначе метки будут слишком плотными на мобильном)
        if (!isMobile || i % 2 === 0) {

            // добавляем значение для деления оси X (используем строку в формате YYYY-MM-DD как категорию)
            tickVals.push(d.toISOString().slice(0, 10)); // Возвращает "YYYY-MM-DD" (именно в таком формате летят данные с daily)

            // Подписи можно оставить в любом удобном формате
            tickTexts.push(d.toISOString().slice(0, 10).replace(/-/g, '.'));
        }
    }

    // Возвращаем конфигурацию оси X для дневного графика
    return {
        ...chartLayout, // берём базовую схему графика (иначе не будут применены общие стили)
        xaxis: {
            range     : [tickVals[0], tickVals[tickVals.length - 1]], // диапазон — по категориям
            type      : 'category', // ось X теперь это просто строчная шкала (иначе при date поедет график из-за обрезанных UTC дат с backend)
            tickvals  : tickVals,   // строки дат в ISO формате "YYYY-MM-DD"
            ticktext  : tickTexts,  // подписи на оси X (формат даты YYYY.MM.DD)
            tickangle : -90,        // поворачиваем подписи вертикально для лучшей читаемости (иначе подписи могут накладываться)
        }
    };
})();



// === Подготовка трасс\линий графиков (расположение точек + дизайн) === //
function createChartTraces(chartEntities, vacancyStats, defaultView, region) {

    const traces = [];

    for (const chartEntity of chartEntities) {

        // Получаем daily или hourly статистику по конкретному объекту или по всем объектам
        const vals = (vacancyStats[chartEntity.code] || vacancyStats)[defaultView];

        // Формируем из сырых ISO дат массив дат для оси x
        const x = vals.map(([rawDate]) =>
            defaultView === 'hourly'
                ? new Date(rawDate + 'Z')  // для hourly графика - преобразуем в локализованные Date (летят с бэка в формате "YYYY-MM-DD HH:MM:SS"),
                : rawDate                        // для daily графика  - отдаём как есть (летят с бэка в формате "YYYY-MM-DD")
        );


        // Формируем массив y — значения, зависящие от региона и от формата данных (daily/hourly)
        const y = vals.map(([, value]) =>
                // данные с бэка летят либо {[Москва, Россия]}, либо {Россия}
                // получается, если значение — массив, то выбираем элемент в зависимости от региона
                Array.isArray(value)
                    ? (region === 'moscow' ? value[0] : value[1]) // для Москвы берем первый элемент, для России второй элемент
                    : value                                       // если не массив — берем значение как есть (значит Россия)
        );

        // Добавляем конфигурацию линии графика в массив traces
        traces.push({
            x,                                                               // массив значений X (даты)
            y,                                                               // массив значений Y (количество вакансий)
            mode            : 'lines+markers',                               // стиль графика — линии с точками
            name            : chartEntity.name + '\u00A0\u00A0\u00A0\u00A0', // название с отступами для легенды (иначе названия и линии в легенде будут стоять в один ряд и станет непонятно к чему относится название - к левому элементу или правому)
            marker          : { color: chartEntity.color },                  // цвет линии
            line            : { shape: 'linear', width: 2 },                 // линия — прямая с шириной 2
            hovertemplate   : '%{y}<extra></extra>'                          // всплывающая подсказка: отображать значение Y
        });
    }

    // Если больше одного графика — сортируем их по убыванию последнего значения y (для совпадения списка легенды с иерархией линий на графике)
    if (traces.length > 1) {traces.sort((a, b) => b.y[b.y.length - 1] - a.y[a.y.length - 1]);}

    return traces;
}



// === Отрисовка графика с помощью Plotly (может принимать одну или несколько линий) === //
export function renderChart({
    htmlContainerId,        // id DOM-элемента, в котором будет график
    vacancyStats,           // данные статистики по объектам для построения графика
    chartEntities,          // набор сущностей (линий) их имен и цветов, которые нужно отобразить
    switchable,             // флаг — можно ли переключаться между daily/hourly
    defaultView,            // стартовое представление (daily или hourly)
    showLegend,             // отображать ли легенду для графика
    height,                 // кастомная высота графика
    region='russia'  // Москва/Россия (по умолчанию Россия)
}) {

    // Основная функция отрисовки графика
    const draw = () => {

        // Готовим трассы/линии которые будем рисовать на графике
        const traces = createChartTraces(chartEntities, vacancyStats, defaultView, region);

        // Очищаем предыдущую отрисовку графика (иначе будут "наложения" при повторной отрисовке)
        Plotly.purge(htmlContainerId);

        // берём базовый макет
        const baseLayout = defaultView === 'daily' ? dailyChartLayout : hourlyChartLayout;

        // создаём копию с возможным изменением высоты
        const layout = {
            ...baseLayout,
            showlegend: showLegend,
            dragmode: false,
            ...(height ? {height} : {}) // если height передан, используем его
        };

        // // Формируем конфигурацию графика:
        // const layout = {
        //     ...(defaultView === 'daily' ? dailyChartLayout : hourlyChartLayout), // выбираем макет графика в зависимости от выбранного режима
        //     showlegend  : showLegend,                                            // отображать ли легенду с графиком
        //     dragmode    : false                                                  // отключаем возможность перетаскивать/увеличивать сетку графика пальцем или мышкой
        // };

        // Отрисовываем график в контейнере (.react() обновит график если он уже есть (иначе .newPlot())
        Plotly.react(htmlContainerId, traces, layout, {
            displayModeBar : false,  // отключаем toolbar управления графиком (кнопки и прочее)
            responsive     : true    // делаем адаптивным (График будет автоматически подстраиваться под размер HTML-контейнера)
        });
    };

    // Первая отрисовка графика при загрузке
    draw();

    // Переключение между дневным и почасовым режимом по клику на график (если включено)
    if (switchable) {
        document.getElementById(htmlContainerId)?.addEventListener('click', () => {

            // Меняем режим отображения: daily <-> hourly
            defaultView = defaultView === 'daily' ? 'hourly' : 'daily';

            // Повторно отрисовываем график с новым режимом
            draw();
        });
    }
}



// === Основной запуск графиков === //
export const initCharts = async () => {
    try {

        await loadLanguagesIfNeeded();
        await loadVacanciesIfNeeded();

        renderChart({
            htmlContainerId         : 'chart_software_developer',
            vacancyStats            : {software_developer: getVacanciesData()['software_developer']},
            chartEntities           : [{code: 'software_developer', name: 'Разработчик ПО', color: 'crimson'}],
            switchable              : true,
            defaultView             : 'hourly',
            showLegend              : false,
        });

        renderChart({
            htmlContainerId         : 'chart_all_languages',
            vacancyStats            : getVacanciesData(), // получаем кэшированные данные по вакансиям,
            chartEntities           : getLanguagesData(),
            switchable              : false,
            defaultView             : 'daily',
            showLegend              : true,
            height                  : isMobile ? 450 : 450 // увеличенная высота
        });

    } catch (e) {
        console.error('Ошибка загрузки данных или отрисовки графиков:', e);
    }
};